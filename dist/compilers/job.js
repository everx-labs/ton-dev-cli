"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilersJob = void 0;

var _dev = require("../dev");

var _utils = require("../utils/utils");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const os = require('os');

class CompilersJob {
  constructor(dev, container, srcPath, dstPath) {
    _defineProperty(this, "dev", void 0);

    _defineProperty(this, "container", void 0);

    _defineProperty(this, "hostPath", void 0);

    _defineProperty(this, "guestPath", void 0);

    this.dev = dev;
    this.container = container;
    this.hostPath = srcPath;
    this.guestPath = dstPath;
  }

  static async create(dev, path) {
    const hostPath = (0, _utils.bindPathJoinTo)(path);
    const {
      container,
      guestPath
    } = await dev.getCompilersMountedTo(hostPath());
    return new CompilersJob(dev, container, hostPath, guestPath);
  }

  async run(...args) {
    const container = this.container;

    if (os.platform() === 'win32') {
      return (0, _utils.run)('docker', 'exec', container.id, ...args);
    }

    return new Promise((resolve, reject) => {
      container.exec({
        Cmd: args,
        Tty: true,
        AttachStdin: true,
        AttachStdout: true,
        AttachStderr: true
      }, (err, exec) => {
        if (err) {
          reject(err);
          return;
        }

        exec.start((err, stream) => {
          if (err) {
            reject(err);
            return;
          }

          container.modem.demuxStream(stream, process.stdout, process.stderr);

          const checkForResult = () => {
            exec.inspect((err, data) => {
              if (err) {
                reject(err);
                return;
              }

              if (data.Running) {
                setTimeout(checkForResult, 10);
              } else {
                resolve(data);
              }
            });
          };

          checkForResult();
        });
      });
    });
  }

}

exports.CompilersJob = CompilersJob;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21waWxlcnMvam9iLmpzIl0sIm5hbWVzIjpbIm9zIiwicmVxdWlyZSIsIkNvbXBpbGVyc0pvYiIsImNvbnN0cnVjdG9yIiwiZGV2IiwiY29udGFpbmVyIiwic3JjUGF0aCIsImRzdFBhdGgiLCJob3N0UGF0aCIsImd1ZXN0UGF0aCIsImNyZWF0ZSIsInBhdGgiLCJnZXRDb21waWxlcnNNb3VudGVkVG8iLCJydW4iLCJhcmdzIiwicGxhdGZvcm0iLCJpZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXhlYyIsIkNtZCIsIlR0eSIsIkF0dGFjaFN0ZGluIiwiQXR0YWNoU3Rkb3V0IiwiQXR0YWNoU3RkZXJyIiwiZXJyIiwic3RhcnQiLCJzdHJlYW0iLCJtb2RlbSIsImRlbXV4U3RyZWFtIiwicHJvY2VzcyIsInN0ZG91dCIsInN0ZGVyciIsImNoZWNrRm9yUmVzdWx0IiwiaW5zcGVjdCIsImRhdGEiLCJSdW5uaW5nIiwic2V0VGltZW91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWlCQTs7QUFHQTs7OztBQUNBLE1BQU1BLEVBQUUsR0FBR0MsT0FBTyxDQUFDLElBQUQsQ0FBbEI7O0FBRUEsTUFBTUMsWUFBTixDQUFtQjtBQU1mQyxFQUFBQSxXQUFXLENBQ1BDLEdBRE8sRUFFUEMsU0FGTyxFQUdQQyxPQUhPLEVBSVBDLE9BSk8sRUFLVDtBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUNFLFNBQUtILEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsU0FBS0csUUFBTCxHQUFnQkYsT0FBaEI7QUFDQSxTQUFLRyxTQUFMLEdBQWlCRixPQUFqQjtBQUNIOztBQUVELGVBQWFHLE1BQWIsQ0FBb0JOLEdBQXBCLEVBQThCTyxJQUE5QixFQUE0QztBQUN4QyxVQUFNSCxRQUFRLEdBQUcsMkJBQWVHLElBQWYsQ0FBakI7QUFDQSxVQUFNO0FBQUNOLE1BQUFBLFNBQUQ7QUFBWUksTUFBQUE7QUFBWixRQUF5QixNQUFNTCxHQUFHLENBQUNRLHFCQUFKLENBQTBCSixRQUFRLEVBQWxDLENBQXJDO0FBQ0EsV0FBTyxJQUFJTixZQUFKLENBQWlCRSxHQUFqQixFQUFzQkMsU0FBdEIsRUFBaUNHLFFBQWpDLEVBQTJDQyxTQUEzQyxDQUFQO0FBQ0g7O0FBRUQsUUFBTUksR0FBTixDQUFVLEdBQUdDLElBQWIsRUFBNkI7QUFDekIsVUFBTVQsU0FBUyxHQUFHLEtBQUtBLFNBQXZCOztBQUNBLFFBQUlMLEVBQUUsQ0FBQ2UsUUFBSCxPQUFrQixPQUF0QixFQUErQjtBQUMzQixhQUFPLGdCQUFJLFFBQUosRUFBYyxNQUFkLEVBQXNCVixTQUFTLENBQUNXLEVBQWhDLEVBQW9DLEdBQUdGLElBQXZDLENBQVA7QUFDSDs7QUFDRCxXQUFPLElBQUlHLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDcENkLE1BQUFBLFNBQVMsQ0FBQ2UsSUFBVixDQUFlO0FBQ1hDLFFBQUFBLEdBQUcsRUFBRVAsSUFETTtBQUVYUSxRQUFBQSxHQUFHLEVBQUUsSUFGTTtBQUdYQyxRQUFBQSxXQUFXLEVBQUUsSUFIRjtBQUlYQyxRQUFBQSxZQUFZLEVBQUUsSUFKSDtBQUtYQyxRQUFBQSxZQUFZLEVBQUU7QUFMSCxPQUFmLEVBTUcsQ0FBQ0MsR0FBRCxFQUFNTixJQUFOLEtBQWU7QUFDZCxZQUFJTSxHQUFKLEVBQVM7QUFDTFAsVUFBQUEsTUFBTSxDQUFDTyxHQUFELENBQU47QUFDQTtBQUNIOztBQUNETixRQUFBQSxJQUFJLENBQUNPLEtBQUwsQ0FBVyxDQUFDRCxHQUFELEVBQU1FLE1BQU4sS0FBaUI7QUFDeEIsY0FBSUYsR0FBSixFQUFTO0FBQ0xQLFlBQUFBLE1BQU0sQ0FBQ08sR0FBRCxDQUFOO0FBQ0E7QUFDSDs7QUFFRHJCLFVBQUFBLFNBQVMsQ0FBQ3dCLEtBQVYsQ0FBZ0JDLFdBQWhCLENBQTRCRixNQUE1QixFQUFvQ0csT0FBTyxDQUFDQyxNQUE1QyxFQUFvREQsT0FBTyxDQUFDRSxNQUE1RDs7QUFFQSxnQkFBTUMsY0FBYyxHQUFHLE1BQU07QUFDekJkLFlBQUFBLElBQUksQ0FBQ2UsT0FBTCxDQUFhLENBQUNULEdBQUQsRUFBTVUsSUFBTixLQUFlO0FBQ3hCLGtCQUFJVixHQUFKLEVBQVM7QUFDTFAsZ0JBQUFBLE1BQU0sQ0FBQ08sR0FBRCxDQUFOO0FBQ0E7QUFDSDs7QUFDRCxrQkFBSVUsSUFBSSxDQUFDQyxPQUFULEVBQWtCO0FBQ2RDLGdCQUFBQSxVQUFVLENBQUNKLGNBQUQsRUFBaUIsRUFBakIsQ0FBVjtBQUNILGVBRkQsTUFFTztBQUNIaEIsZ0JBQUFBLE9BQU8sQ0FBQ2tCLElBQUQsQ0FBUDtBQUNIO0FBQ0osYUFWRDtBQVdILFdBWkQ7O0FBYUFGLFVBQUFBLGNBQWM7QUFDakIsU0F0QkQ7QUF1QkgsT0FsQ0Q7QUFtQ0gsS0FwQ00sQ0FBUDtBQXFDSDs7QUFsRWMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTgtMjAyMCBUT04gREVWIFNPTFVUSU9OUyBMVEQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIFNPRlRXQVJFIEVWQUxVQVRJT04gTGljZW5zZSAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXG4gKiB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbiAqIExpY2Vuc2UgYXQ6IGh0dHBzOi8vd3d3LnRvbi5kZXYvbGljZW5zZXNcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIFRPTiBERVYgc29mdHdhcmUgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbi8vIEBmbG93XG5cbmltcG9ydCB7IERldiB9IGZyb20gXCIuLi9kZXZcIjtcbmltcG9ydCB0eXBlIHsgRG9ja2VyQ29udGFpbmVyIH0gZnJvbSBcIi4uL3V0aWxzL2RvY2tlclwiO1xuaW1wb3J0IHR5cGUgeyBQYXRoSm9pbiB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuaW1wb3J0IHsgYmluZFBhdGhKb2luVG8sIHJ1biB9IGZyb20gXCIuLi91dGlscy91dGlsc1wiO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5jbGFzcyBDb21waWxlcnNKb2Ige1xuICAgIGRldjogRGV2O1xuICAgIGNvbnRhaW5lcjogRG9ja2VyQ29udGFpbmVyO1xuICAgIGhvc3RQYXRoOiBQYXRoSm9pbjtcbiAgICBndWVzdFBhdGg6IFBhdGhKb2luO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGRldjogRGV2LFxuICAgICAgICBjb250YWluZXI6IERvY2tlckNvbnRhaW5lcixcbiAgICAgICAgc3JjUGF0aDogUGF0aEpvaW4sXG4gICAgICAgIGRzdFBhdGg6IFBhdGhKb2luLFxuICAgICkge1xuICAgICAgICB0aGlzLmRldiA9IGRldjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuaG9zdFBhdGggPSBzcmNQYXRoO1xuICAgICAgICB0aGlzLmd1ZXN0UGF0aCA9IGRzdFBhdGg7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShkZXY6IERldiwgcGF0aDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGhvc3RQYXRoID0gYmluZFBhdGhKb2luVG8ocGF0aCk7XG4gICAgICAgIGNvbnN0IHtjb250YWluZXIsIGd1ZXN0UGF0aH0gPSBhd2FpdCBkZXYuZ2V0Q29tcGlsZXJzTW91bnRlZFRvKGhvc3RQYXRoKCkpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVyc0pvYihkZXYsIGNvbnRhaW5lciwgaG9zdFBhdGgsIGd1ZXN0UGF0aCk7XG4gICAgfVxuXG4gICAgYXN5bmMgcnVuKC4uLmFyZ3M6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bignZG9ja2VyJywgJ2V4ZWMnLCBjb250YWluZXIuaWQsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb250YWluZXIuZXhlYyh7XG4gICAgICAgICAgICAgICAgQ21kOiBhcmdzLFxuICAgICAgICAgICAgICAgIFR0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBBdHRhY2hTdGRpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBBdHRhY2hTdGRvdXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgQXR0YWNoU3RkZXJyOiB0cnVlLFxuICAgICAgICAgICAgfSwgKGVyciwgZXhlYykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhlYy5zdGFydCgoZXJyLCBzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIubW9kZW0uZGVtdXhTdHJlYW0oc3RyZWFtLCBwcm9jZXNzLnN0ZG91dCwgcHJvY2Vzcy5zdGRlcnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrRm9yUmVzdWx0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlYy5pbnNwZWN0KChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLlJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0ZvclJlc3VsdCwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7XG4gICAgQ29tcGlsZXJzSm9iXG59XG4iXX0=